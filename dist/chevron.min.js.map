{"version":3,"sources":["chevron.js"],"names":["Chevron","extend","type","cf","_this","this","name","deps","fn","provider","initialize","module","list","rdy","dependencies","forEach","item","dependency","push","recurseDependencies","chev","get","Error","prepare","init","entry","set","access","service","serviceFn","apply","concat","Array","from","arguments","factory","unshift","Function","prototype","bind","Map"],"mappings":"AAMA,GAAIA,SAAW,WACf,YASA,IAAIC,GAAS,SAAgBC,EAAMC,GAC/B,GAAIC,GAAQC,IAYZ,OATAD,GAAMF,GAAQ,SAAUI,EAAMC,EAAMC,GAChC,MAAOJ,GAAMK,SAASP,EACtBC,EACAG,EACAC,EACAC,IAIGJ,GAYPM,EAAa,SAAoBC,EAAQC,EAAMT,GAuB/C,MArBKQ,GAAOE,MACR,WACI,GAAIC,KAGJH,GAAOJ,KAAKQ,QAAQ,SAAUC,GAC1B,GAAIC,GAAaL,EAAKI,EAGlBC,IACAH,EAAaI,KAAKD,EAAWT,MAMrCG,EAASR,EAAGQ,EAAQG,GACpBH,EAAOE,KAAM,KAIdF,GAWPQ,EAAsB,QAASA,GAAoBC,EAAMT,EAAQH,GAEjEG,EAAOJ,KAAKQ,QAAQ,SAAUT,GAC1B,GAAIW,GAAaG,EAAKC,IAAIf,EAE1B,KAAIW,EAOA,KAAM,IAAIK,OAAMX,EAAOL,KAAO,oBAAsBA,EAAO,IAL3Da,GAAoBC,EAAMH,EAAYT,GAEtCA,EAAGS,MAgBXM,EAAU,SAAiBH,EAAMT,EAAQR,GACzC,GAAIS,KAUJ,OAPAO,GAAoBC,EAAMT,EAE1B,SAAUM,GAENL,EAAKK,EAAWX,MAAQW,EAAWO,SAGhCd,EAAWC,EAAQC,EAAMT,IAYhCM,EAAW,SAAkBP,EAAMC,EAAIG,EAAMC,EAAMC,GACnD,GAAIJ,GAAQC,KACRoB,GACAvB,KAAMA,EACNI,KAAMA,EACNC,KAAMA,EACNC,GAAIA,EACJK,KAAK,EACLW,KAAM,WACF,MAAOD,GAAQnB,EAAMgB,KAAMK,EAAOtB,IAO1C,OAFAC,GAAMgB,KAAKM,IAAIpB,EAAMmB,GAEdrB,GASPuB,EAAS,SAAgBrB,GAC3B,MAAOD,MAAKe,KAAKC,IAAIf,GAAMkB,OAAOhB,IAWhCoB,EAAU,SAAiBjB,EAAQG,GAEnC,GAAIe,GAAYlB,EAAOH,EAQvB,OANAG,GAAOH,GAAK,WAGR,MAAOqB,GAAUC,MAAM,KAAMhB,EAAaiB,OAAOC,MAAMC,KAAKC,cAGzDvB,GAWPwB,EAAU,SAAiBxB,EAAQG,GAQnC,MANAA,GAAasB,QAAQ,GAIrBzB,EAAOH,GAAK,IAAK6B,SAASC,UAAUC,KAAKT,MAAMnB,EAAOH,GAAIM,IAEnDH,GAQPX,EAAU,WACV,GAAII,GAAQC,IAEZD,GAAMgB,KAAO,GAAIoB,KAGjBpC,EAAMH,OAAO,UAAW2B,GACxBxB,EAAMH,OAAO,UAAWkC,GAY5B,OANAnC,GAAQsC,WACJrC,OAAQA,EACRQ,SAAUA,EACVkB,OAAQA,GAGL3B","file":"chevron.min.js","sourcesContent":["/**\n * Chevron v6.1.1\n * Author: Felix Rilling\n * Repository: git+https://github.com/FelixRilling/chevronjs.git\n */\n\nvar Chevron = (function () {\n'use strict';\n\n/**\r\n * Adds a new module type to the Chevron instance\r\n * @param {String} type The name of the type\r\n * @param {Function} cf Constructor function to init the module with\r\n * @returns {Object} Chevron instance\r\n */\n\nvar extend = function extend(type, cf) {\n    var _this = this;\n\n    //Add customType method to container\n    _this[type] = function (name, deps, fn) {\n        return _this.provider(type, //static\n        cf, //static\n        name, //dynamic\n        deps, //dynamic\n        fn //dynamic\n        );\n    };\n\n    return _this;\n};\n\n/**\r\n * Collects dependencies and initializes module\r\n * @private\r\n * @param {Object} module The module to check\r\n * @param {Object} list The list of dependencies\r\n * @param {Function} cf The Constructor function\r\n * @returns {Object} Initialized module\r\n */\n\nvar initialize = function initialize(module, list, cf) {\n    //Only init if its not already initializes\n    if (!module.rdy) {\n        (function () {\n            var dependencies = [];\n\n            //Collect an ordered Array of dependencies\n            module.deps.forEach(function (item) {\n                var dependency = list[item];\n\n                //If the dependency name is found in the list of deps, add it\n                if (dependency) {\n                    dependencies.push(dependency.fn);\n                }\n            });\n\n            //Init module\n            //Call Constructor fn with module/deps\n            module = cf(module, dependencies);\n            module.rdy = true;\n        })();\n    }\n\n    return module;\n};\n\n/**\r\n * Loops trough dependencies, recurse if new dependencies has dependencies itself; then execute fn.\r\n * @private\r\n * @param {Object} chev The chevron container\r\n * @param {Array} module The dependencyList to iterate\r\n * @param {Function} fn The function run over each dependency\r\n */\n\nvar recurseDependencies = function recurseDependencies(chev, module, fn) {\n    //loop trough deps\n    module.deps.forEach(function (name) {\n        var dependency = chev.get(name);\n\n        if (dependency) {\n            //recurse over sub-deps\n            recurseDependencies(chev, dependency, fn);\n            //run fn\n            fn(dependency);\n        } else {\n            //if the dependency isnot found, throw error with name\n            throw new Error(module.name + \" is missing dep '\" + name + \"'\");\n        }\n    });\n};\n\n/**\r\n * Inits module and all dependencies\r\n * @private\r\n * @param {Object} chev The chevron container\r\n * @param {Object} module The module to prepare\r\n * @param {Function} cf The constructor function\r\n * @returns {Object} Initialized module\r\n */\nvar prepare = function prepare(chev, module, cf) {\n    var list = {};\n\n    //Recurse trough module deps\n    recurseDependencies(chev, module,\n    //run this over every dependency to add it to the dependencyList\n    function (dependency) {\n        //make sure if dependency is initialized, then add\n        list[dependency.name] = dependency.init();\n    });\n\n    return initialize(module, list, cf);\n};\n\n/**\r\n * Adds a new module to the container\r\n * @param {String} type The type of the module. ex: \"factory\"\r\n * @param {Function} cf The constructor function of the module\r\n * @param {String} name The name to register the module under. ex: \"myFactory\"\r\n * @param {Array} deps Array of dependenciy names\r\n * @param {Function} fn Content of the module\r\n * @returns {Object} Chevron instance\r\n */\nvar provider = function provider(type, cf, name, deps, fn) {\n    var _this = this;\n    var entry = {\n        type: type, //Type of the module\n        name: name, //Name of the module\n        deps: deps, //Array of dependencies\n        fn: fn, //Module content function\n        rdy: false, //If the module is ready to access\n        init: function init() {\n            return prepare(_this.chev, entry, cf); //init the module\n        }\n    };\n\n    //Saves entry to chev container\n    _this.chev.set(name, entry);\n\n    return _this;\n};\n\n/**\r\n * Access module with dependencies bound\r\n * @param {String} name The name of the module to access\r\n * @returns {Mixed} Initialized Object content\r\n */\n\nvar access = function access(name) {\n  return this.chev.get(name).init().fn;\n};\n\n/**\r\n * Constructor function for the service type\r\n * @private\r\n * @param {Object} module The module object\r\n * @param {Array} dependencies Array of dependency contents\r\n * @returns {Mixed} Initialized module\r\n */\n\nvar service = function service(module, dependencies) {\n    //Dereference fn to avoid unwanted recursion\n    var serviceFn = module.fn;\n\n    module.fn = function () {\n        //Chevron service function wrapper\n        //return function with args injected\n        return serviceFn.apply(null, dependencies.concat(Array.from(arguments)));\n    };\n\n    return module;\n};\n\n/**\r\n * Constructor function for the factory type\r\n * @private\r\n * @param {Object} module The module object\r\n * @param {Array} dependencies Array of dependency contents\r\n * @returns {Mixed} Initialized module\r\n */\n\nvar factory = function factory(module, dependencies) {\n    //First value gets ignored by calling 'new' like this, so we need to fill it with something\n    dependencies.unshift(0);\n\n    //Apply into new constructor by binding applying the bind method.\n    //@see: {@link http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible }\n    module.fn = new (Function.prototype.bind.apply(module.fn, dependencies))();\n\n    return module;\n};\n\n/**\r\n * Chevron Constructor\r\n * @constructor\r\n * @returns {Object} Chevron instance\r\n */\nvar Chevron = function Chevron() {\n    var _this = this;\n\n    _this.chev = new Map(); //Instance container\n\n    //Init default types\n    _this.extend(\"service\", service);\n    _this.extend(\"factory\", factory);\n};\n\n/**\r\n * Expose Chevron methods\r\n */\nChevron.prototype = {\n    extend: extend, //Creates a new module type\n    provider: provider, //Adds a new custom module to the container\n    access: access //Returns initialized module\n};\n\nreturn Chevron;\n\n}());\n\n//# sourceMappingURL=chevron.js.map\n"]}