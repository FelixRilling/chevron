{"version":3,"sources":["chevron.js"],"names":["Chevron","typeService","moduleContent","dependencies","serviceFn","apply","concat","Array","from","arguments","typeFactory","dependenciesArr","unshift","Function","prototype","bind","construct","$map","_module","constructorFunction","deps","forEach","depName","dependency","get","Error","push","rdy","fn","init","ChevronMain","[object Object]","_this","this","Map","extend","typeName","id","provider","set"],"mappings":"AAMA,GAAIA,SAAW,WACf,YAEA,MAAMC,GAAc,SAAUC,EAAeC,GAEzC,KAAMC,GAAYF,CAQlB,OANAA,GAAgB,WAGZ,MAAOE,GAAUC,MAAM,KAAMF,EAAaG,OAAOC,MAAMC,KAAKC,eAM9DC,EAAc,SAAUR,EAAeC,GAEzC,KAAMQ,GAAkBJ,MAAMC,KAAKL,EAQnC,OANAQ,GAAgBC,QAAQ,GAIxBV,EAAgB,IAAKW,SAASC,UAAUC,KAAKV,MAAMH,EAAeS,KAahEK,EAAY,SAAUC,EAAMC,EAASC,GACvC,KAAMhB,KAgBN,OAbAe,GAAQE,KAAKC,QAAQC,IACjB,KAAMC,GAAaN,EAAKO,IAAIF,EAE5B,KAAIC,EAGA,KAAM,IAAIE,mBAAmBH,KAF7BnB,GAAauB,KAAKH,EAAWI,IAAMJ,EAAWK,GAAKL,EAAWM,UAMtEX,EAAQU,GAAKT,EAAoBD,EAAQU,GAAIzB,GAC7Ce,EAAQS,KAAM,EAEPT,EAAQU,IAQbE,QACFC,cACI,KAAMC,GAAQC,IAGdD,GAAMf,KAAO,GAAIiB,KAGjBF,EAAMG,OAAO,UAAWlC,GACxB+B,EAAMG,OAAO,UAAWzB,GAE5BqB,OAAOK,EAAUjB,GAIb,KAAMa,GAAQC,IAOd,OAJAD,GAAMI,GAAY,SAAUC,EAAIjB,EAAMQ,GAClCI,EAAMM,SAASD,EAAIjB,EAAMQ,EAAIT,IAG1Ba,EAEXD,SAASM,EAAIjB,EAAMQ,EAAIT,GAInB,KAAMa,GAAQC,KACRf,GACFE,KAAAA,EACAQ,GAAAA,EACAD,KAAK,EACLE,KAAM,WACF,MAAOb,GAAUgB,EAAMf,KAAMC,EAASC,IAM9C,OAFAa,GAAMf,KAAKsB,IAAIF,EAAInB,GAEZc,EAEXD,OAAOM,GAIH,KAAMnB,GAAUe,KAAKhB,KAAKO,IAAIa,EAE9B,OAAOnB,GAAQS,IAAMT,EAAQU,GAAKV,EAAQW,QAIlD,OAAOC","file":"chevron.min.js","sourcesContent":["/**\n * Chevron 7.0.0\n * Author: Felix Rilling\n * Repository: git+https://github.com/FelixRilling/chevronjs.git\n */\n\nvar Chevron = (function () {\n'use strict';\n\nconst typeService = function (moduleContent, dependencies) {\n    //Dereference fn to avoid unwanted recursion\n    const serviceFn = moduleContent;\n\n    moduleContent = function () {\n        //Chevron service function wrapper\n        //return function with args injected\n        return serviceFn.apply(null, dependencies.concat(Array.from(arguments)));\n    };\n\n    return moduleContent;\n};\n\nconst typeFactory = function (moduleContent, dependencies) {\n    //dereference array, because we dont wanna mutate the arg\n    const dependenciesArr = Array.from(dependencies);\n    //First value gets ignored by calling 'new' like this, so we need to fill it with something\n    dependenciesArr.unshift(0);\n\n    //Apply into new constructor by binding applying the bind method.\n    //@see: {@link http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible }\n    moduleContent = new (Function.prototype.bind.apply(moduleContent, dependenciesArr))();\n\n    return moduleContent;\n};\n\n/**\n * @private\n * @param {Map} $map Chevron instance map\n * @param {Object} _module module\n * @param {Function} constructorFunction function init the module with\n * @returns {Mixed} constructed module content\n */\n\nconst construct = function ($map, _module, constructorFunction) {\n    const dependencies = [];\n\n    //Collects dependencies\n    _module.deps.forEach(depName => {\n        const dependency = $map.get(depName);\n\n        if (dependency) {\n            dependencies.push(dependency.rdy ? dependency.fn : dependency.init());\n        } else {\n            throw new Error(`Missing '${ depName }'`);\n        }\n    });\n\n    _module.fn = constructorFunction(_module.fn, dependencies);\n    _module.rdy = true;\n\n    return _module.fn;\n};\n\n/**\n * Chevron Constructor\n * @constructor\n * @returns {Object} Chevron instance\n */\nconst ChevronMain = class {\n    constructor() {\n        const _this = this;\n\n        //Instance container\n        _this.$map = new Map();\n\n        //Adds default types\n        _this.extend(\"service\", typeService);\n        _this.extend(\"factory\", typeFactory);\n    }\n    extend(typeName, constructorFunction) {\n        /**\n         * Defines a new module type\n         */\n        const _this = this;\n\n        //stores type with name into instance\n        _this[typeName] = function (id, deps, fn) {\n            _this.provider(id, deps, fn, constructorFunction);\n        };\n\n        return _this;\n    }\n    provider(id, deps, fn, constructorFunction) {\n        /**\n         * Adds a new module to the container\n         */\n        const _this = this;\n        const _module = {\n            deps,\n            fn,\n            rdy: false,\n            init: function () {\n                return construct(_this.$map, _module, constructorFunction);\n            }\n        };\n\n        _this.$map.set(id, _module);\n\n        return _this;\n    }\n    access(id) {\n        /**\n         * Accesses and inits a module\n         */\n        const _module = this.$map.get(id);\n\n        return _module.rdy ? _module.fn : _module.init();\n    }\n};\n\nreturn ChevronMain;\n\n}());\n\n//# sourceMappingURL=chevron.js.map\n"]}