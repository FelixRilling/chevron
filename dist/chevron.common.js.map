{"version":3,"file":"chevron.common.js","sources":["../node_modules/lightdash/dist/esm/src/object/name.js","esm/src/bootstrap/identityBootstrapper.js","esm/src/Chevron.js","esm/src/bootstrap/classBootstrapper.js","esm/src/bootstrap/functionBootstrapper.js","esm/src/decorators/Injectable.js","esm/src/decorators/Autowired.js"],"sourcesContent":["import { isObject, isString, isSymbol } from \"lodash\";\n/**\n * Gets name of a value.\n *\n * If the value has a name or description property, the value of that is returned.\n * If the value is a string, it is returned as is.\n * Otherwise null is returned.\n *\n * @since 10.2.0\n * @memberOf Object\n * @param value Value to check.\n * @returns The name of the value.\n * @example\n * name(class Foo{})\n * // => \"Foo\"\n *\n * name(function bar(){})\n * // => \"bar\"\n *\n * name(Symbol(\"abc\"))\n * // => \"abc\"\n *\n * name(\"foo\")\n * // => \"foo\"\n *\n * name(1)\n * // => null\n */\nconst name = (value) => {\n    if (isString(value)) {\n        return value;\n    }\n    // eslint-disable-next-line no-extra-parens\n    if (isObject(value) && isString(value.name)) {\n        // eslint-disable-next-line no-extra-parens\n        return value.name;\n    }\n    if (isSymbol(value) && isString(value.description)) {\n        return value.description;\n    }\n    return null;\n};\nexport { name };\n//# sourceMappingURL=name.js.map","const identityBootstrapper = (initializer) => initializer;\nexport { identityBootstrapper };\n//# sourceMappingURL=identityBootstrapper.js.map","import { isNil, isString } from \"lodash\";\nimport { name as getName } from \"lightdash\";\nimport { identityBootstrapper } from \"./bootstrap/identityBootstrapper\";\nclass Chevron {\n    /**\n     * Main chevron class.\n     *\n     * @public\n     * @class Chevron\n     */\n    constructor() {\n        this.injectables = new Map();\n    }\n    /**\n     * Gets a bootstrapped injectable from the chevron instance.\n     *\n     * @public\n     * @param {*} key Key of the injectable to get.\n     * @returns {*} Bootstrapped content of the injectable.\n     * @throws Error when the key cannot be found, or circular dependencies exist.\n     */\n    get(name) {\n        return this.resolveEntry(name, new Set());\n    }\n    /**\n     * Checks if the chevron instance has a given injectable.\n     *\n     * @public\n     * @param {*} name Key of the injectable to check.\n     * @returns {boolean} If the chevron instance has a given injectable.\n     */\n    has(name) {\n        return this.injectables.has(isString(name) ? name : this.getKey(name));\n    }\n    /**\n     * Sets a new injectable on the chevron instance.\n     *\n     * @public\n     * @param {*} initializer Content of the injectable.\n     * @param {string} bootstrapFn Type of the injectable.\n     * @param {string[]} dependencies Array of dependency keys.\n     * @param {*?} name? Custom key of the injectable. If none is given, the initializer will be used.\n     * @throws Error when the key already exists, or the type is invalid.\n     */\n    register(initializer, bootstrapFn = identityBootstrapper, dependencies = [], name = null) {\n        const key = !isNil(name) ? name : this.getKey(initializer);\n        if (this.injectables.has(key)) {\n            throw new Error(`Key already exists: '${key}'.`);\n        }\n        this.injectables.set(key, {\n            bootstrapFn: bootstrapFn,\n            dependencies,\n            initializer,\n            value: null\n        });\n    }\n    resolveEntry(name, resolveStack) {\n        const key = isString(name) ? name : this.getKey(name);\n        if (!this.injectables.has(key)) {\n            throw new Error(`Injectable '${name}' does not exist.`);\n        }\n        const entry = this.injectables.get(key);\n        if (isNil(entry.value)) {\n            /*\n             * Start bootstrapping value.\n             */\n            if (resolveStack.has(key)) {\n                throw new Error(`Circular dependencies found: '${[\n                    ...resolveStack,\n                    key\n                ].join(\"->\")}'.`);\n            }\n            resolveStack.add(key);\n            entry.value = entry.bootstrapFn(entry.initializer, entry.dependencies.map(dependencyName => this.resolveEntry(dependencyName, resolveStack)));\n            resolveStack.delete(key);\n        }\n        return entry.value;\n    }\n    getKey(initializer) {\n        const guessedName = getName(initializer);\n        if (isNil(guessedName)) {\n            throw new TypeError(`Could not guess name of ${initializer}, please explicitly define one.`);\n        }\n        return guessedName;\n    }\n}\nexport { Chevron };\n//# sourceMappingURL=Chevron.js.map","import { isFunction } from \"lodash\";\nconst classBootstrapper = (initializer, dependencies) => {\n    if (!isFunction(initializer)) {\n        throw new TypeError(\"Non-functions cannot be bootstrapped by this bootstrapper.\");\n    }\n    return Reflect.construct(initializer, dependencies);\n};\nexport { classBootstrapper };\n//# sourceMappingURL=classBootstrapper.js.map","import { isFunction } from \"lodash\";\nconst functionBootstrapper = (initializer, dependencies) => (...args) => {\n    if (!isFunction(initializer)) {\n        throw new TypeError(\"Non-functions cannot be bootstrapped by this bootstrapper.\");\n    }\n    return initializer(...dependencies, ...args);\n};\nexport { functionBootstrapper };\n//# sourceMappingURL=functionBootstrapper.js.map","import { identityBootstrapper } from \"../bootstrap/identityBootstrapper\";\n/**\n * Decorator function to be used as TypeScript decorator\n * in order to declare a value to be an injectable which is added to the chevron instance.\n *\n * @param {Chevron} instance Chevron instance to use.\n * @param {string[]} dependencies Array of dependency keys.\n */\nconst Injectable = (instance, bootstrapFn = identityBootstrapper, dependencies = [], name = null) => (target) => {\n    instance.register(target, bootstrapFn, dependencies, name);\n    return target;\n};\nexport { Injectable };\n//# sourceMappingURL=Injectable.js.map","/**\n * Decorator function to be used as TypeScript decorator\n * in order to wire an injectable into a class property.\n *\n * @public\n * @param {Chevron} instance Chevron instance to use.\n * @param {*} key Key of the injectable.\n */\nconst Autowired = (instance, name) => (target, propertyKey) => {\n    target[propertyKey] = instance.get(name);\n};\nexport { Autowired };\n//# sourceMappingURL=Autowired.js.map"],"names":["isString","isObject","isSymbol","isNil","getName","isFunction"],"mappings":"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"}