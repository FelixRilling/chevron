var chevron=function(t){"use strict";const n=t=>null==t,e=(t,n)=>Reflect.construct(t,n),i=t=>t,s=(t,n)=>(function(){return t(...n,...arguments)});class o{constructor(){this.types=new Map,this.setType("plain",i),this.setType("service",s),this.setType("factory",e),this.injectables=new Map}get(t){return this.resolveEntry(t,new Set)}has(t){return this.injectables.has(t)}set(t,e,i,s){if(!this.hasType(t))throw new Error(`Missing type '${t}'.`);const o=n(s)?i:s;if(this.has(o))throw new Error(`Key already exists: '${o}'.`);this.injectables.set(o,{typeBootstrapper:this.types.get(t),dependencies:e,initializer:i,content:null})}hasType(t){return this.types.has(t)}setType(t,n){this.types.set(t,n)}resolveEntry(t,e){if(!this.has(t))throw new Error(`Injectable '${t}' does not exist.`);const i=this.injectables.get(t);return n(i.content)&&this.bootstrap(t,e,i),i.content}bootstrap(t,n,e){if(n.has(t))throw new Error(`Circular dependencies found: '${[...n,t].join("->")}'.`);n.add(t),e.content=e.typeBootstrapper(e.initializer,e.dependencies.map(t=>this.resolveEntry(t,n))),n.delete(t)}}const r=(t,n)=>(e,i)=>{e[i]=t.get(n)},c=(t,n,e,i)=>s=>{t.set(n,e,s,i);return s};return t.Chevron=o,t.Autowired=r,t.Injectable=c,t}({});
//# sourceMappingURL=chevron.min.js.map
