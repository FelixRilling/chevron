var chevron=function(e){"use strict";const t=e=>null==e,s=(e,t)=>Reflect.construct(e,t),n=e=>e,r=(e,t)=>(function(){return e(...t,...arguments)});return e.Chevron=class{constructor(){this.types=new Map,this.setType("plain",n),this.setType("service",r),this.setType("factory",s),this.injectables=new Map}get(e){return this.resolveEntry(e,new Set)}has(e){return this.injectables.has(e)}set(e,s,n,r){if(!this.hasType(e))throw new Error(`Missing type '${e}'.`);const i=t(r)?n:r;if(this.has(i))throw new Error(`Key already exists: '${i}'.`);this.injectables.set(i,{typeBootstrapper:this.types.get(e),dependencies:s,initializer:n,content:null})}hasType(e){return this.types.has(e)}setType(e,t){this.types.set(e,t)}resolveEntry(e,s){if(!this.has(e))throw new Error(`Injectable '${e}' does not exist.`);const n=this.injectables.get(e);return t(n.content)&&this.bootstrap(e,s,n),n.content}bootstrap(e,t,s){if(t.has(e))throw new Error(`Circular dependencies found: '${[...t,e].join("->")}'.`);t.add(e),s.content=s.typeBootstrapper(s.initializer,s.dependencies.map(e=>this.resolveEntry(e,t))),t.delete(e)}},e.Autowired=((e,t)=>(s,n)=>{s[n]=e.get(t)}),e.Injectable=((e,t,s,n)=>r=>(e.set(t,s,r,n),r)),e}({});
//# sourceMappingURL=chevron.min.js.map
