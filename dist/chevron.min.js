var chevron=function(t){"use strict";const n=t=>null==t,e=(t,n)=>Reflect.construct(t,n),i=t=>t,s=(t,n)=>(function(){return t(...n,...arguments)});class r{constructor(){this.types=new Map,this.setType("service",s),this.setType("factory",e),this.setType("plain",i),this.injectables=new Map}get(t){return this.resolveEntry(t,new Set)}has(t){return this.injectables.has(t)}set(t,e,i,s){const r=n(s)?i:s;if(this.has(r))throw new Error(`Key already exists: '${r}'.`);this.injectables.set(r,this.createEntry(t,i,e))}hasType(t){return this.types.has(t)}setType(t,n){this.types.set(t,n)}resolveEntry(t,e){if(e.has(t))throw new Error(`Circular dependencies found: '${[...e,t].join("->")}'.`);if(!this.has(t))throw new Error(`Injectable '${t}' does not exist.`);const i=this.injectables.get(t);return n(i.content)&&(e.add(t),this.bootstrap(i,e),e.delete(t)),i.content}bootstrap(t,n){const e=t.dependencies.map(t=>this.resolveEntry(t,n));t.content=t.typeBootstrapper(t.initializer,e)}createEntry(t,n,e){if(!this.hasType(t))throw new Error(`Missing type '${t}'.`);return{typeBootstrapper:this.types.get(t),dependencies:e,initializer:n,content:null}}}return t.Chevron=r,t}({});
//# sourceMappingURL=chevron.min.js.map
