{"version":3,"sources":["chevron.js"],"names":[],"mappings":"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","file":"chevron.js","sourcesContent":["var Chevron = (function () {\n    'use strict';\n\n    /**\n     * Add a new service/factory to the container\n     * @private\n     * @param String name to register/id the service\n     * @param Array list of dependencies\n     * @param String type of service (service/factory)\n     * @param Function content of the service\n     * @param Array (optional) factory arguments\n     * @return void\n     */\n    function add (name, deps, type, fn, args) {\n        this.chev[name] = {\n            name,\n            type,\n            deps,\n            args: args || [],\n            fn,\n            init: false\n        };\n    }\n\n    const _error = \": error in \";\n    const _factory = \"factory\";\n    const _service = \"service\";\n    const _isUndefined = \" is undefined\";\n\n    /**\n     * Checks if service exist, else add it\n     * @param String name to register/id the service\n     * @param Array list of dependencies\n     * @param String type of service (service/factory)\n     * @param Function content of the service\n     * @return this\n     */\n    function provider(name, deps, type, fn, args) {\n        let _this = this;\n\n        if (_this.chev[name]) {\n            //throw error if a service with this name already exists\n            throw `${_this.id}${_error}${type}: ${_service} '${name}' is already defined`;\n        } else {\n            //Call the add function with bound context\n            add.apply(_this, arguments);\n\n            return _this;\n        }\n    }\n\n    /**\n     * Create a new service\n     * @param String name to register/id the service\n     * @param Array list of dependencies\n     * @param String type of service (service/factory)\n     * @param Function content of the service\n     * @return this\n     */\n    function service (name, deps, fn) {\n        return this.provider(\n            name,\n            deps,\n            _service,\n            fn\n        );\n    }\n\n    /**\n     * Create a new factory\n     * @param String name to register/id the service\n     * @param Array list of dependencies\n     * @param String type of service (service/factory)\n     * @param Function content of the service\n     * @param Array factory arguments\n     * @return this\n     */\n    function factory (name, deps, Constructor, args) {\n        return this.provider(\n            name,\n            deps,\n            _factory,\n            Constructor,\n            args\n        );\n    }\n\n    /**\n     * Misc Utility functions\n     */\n    var util = {\n        /**\n         * Iterate fn over array (faster than Array.prototype.forEach)\n         * @private\n         * @param Array values\n         * @param Function iterate fn\n         * @return void\n         */\n        _each: function (arr, fn) {\n            for (let i = 0, l = arr.length; i < l; i++) {\n                fn(arr[i], i);\n            }\n        },\n        /**\n         * Iterate fn over object\n         * @private\n         * @param Object values\n         * @param Function iterate fn\n         * @return void\n         */\n        _eachObject: function (object, fn) {\n            let keys = Object.keys(object);\n\n            this._each(keys, (key, i) => {\n                fn(object[key], key, i);\n            });\n        }\n    };\n\n    /**\n     * Initializes service/function\n     * @private\n     * @param Object service to check\n     * @param Object bundle of dependencies\n     * @return Object service\n     */\n    function initialize (service, bundle) {\n        if (service.type === _service) {\n            //Construct service\n            let serviceFn = service.fn;\n\n            service.fn = function () {\n                //Chevron service function wrapper\n                return serviceFn.apply(null, bundle.concat(Array.from(arguments)));\n            };\n        } else {\n            //Construct factory\n            bundle = bundle.concat(service.args);\n            //first value gets ignored by calling new like this, so we need to fill it\n            bundle.unshift(null);\n            //Apply into new constructor by accessing bind proto. from: http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\n            service.fn = new(Function.prototype.bind.apply(service.fn, bundle));\n        }\n\n        service.init = true;\n        return service;\n    }\n\n    /**\n     * Collects dependencies and initializes service\n     * @private\n     * @param Object service to check\n     * @param Object list of dependencies\n     * @return Object service\n     */\n    function bundle (service, list) {\n        let bundle = [];\n\n        if (!service.init) {\n            //Collect dependencies for this service\n            util._eachObject(list, (item, key) => {\n                if (service.deps.includes(key)) {\n                    bundle.push(item);\n                }\n            });\n\n            return initialize(service, bundle);\n        } else {\n            return service;\n        }\n    }\n\n    /**\n     * Loops/recurses over list of dependencies\n     * @private\n     * @param Array dependencyList to iterate\n     * @param Function to run over each dependency\n     * @param Function to call on error\n     * @return void\n     */\n    //Loops trough dependencies, recurse if new dependencies has dependencies itself; then execute fn.\n    function r(dependencyList, fn, error) {\n        util._each(dependencyList, name => {\n            let service = this.chev[name];\n\n            if (service) {\n                //recurse if service has dependencies too\n                if (service.deps.length > 0) {\n                    //recurse\n                    r.call(this, service.deps, fn, error);\n                }\n                //run fn\n                fn(service);\n            } else {\n                //if not found error with name\n                error(name);\n            }\n        });\n    }\n\n    /**\n     * Check if every dependency is available\n     * @private\n     * @param Object service to check\n     * @return bound service\n     */\n    function prepare (service) {\n        let list = {};\n\n        //Recurse trough service deps\n        r.call(\n            this,\n            service.deps,\n            //run this over every dependency to add it to the dependencyList\n            dependency => {\n                //make sure if dependency is initialized, then add\n                list[dependency.name] = bundle(dependency, list).fn;\n            },\n            //error if dependency is missing\n            name => {\n                throw `${this.id}${_error}${service.name}: dependency '${name}'${_isUndefined}`;\n            }\n        );\n\n        return bundle(service, list);\n    }\n\n    /**\n     * Access service with dependencies bound\n     * @param String name of the service\n     * @return Function with dependencies bound\n     */\n    function access (name) {\n        let _this = this,\n            accessedService = _this.chev[name];\n\n        //Check if accessed service is registered\n        if (accessedService) {\n            //Call prepare with bound context\n            return prepare.call(_this, accessedService).fn;\n        } else {\n            //throw error if service does not exist\n            throw `${_this.id}${_error}${name}: '${name}'${_isUndefined}`;\n        }\n    }\n\n    /**\n     * Basic Chevron Constructor\n     * @constructor\n     */\n    let Chevron = function (id) {\n        this.id = id || \"cv\";\n        this.chev = {};\n    };\n\n\n    /**\n     * Expose Chevron methods\n     */\n    Chevron.prototype = {\n        //Core service/factory method\n        provider,\n        //Create new service\n        service,\n        //Create new factory\n        factory,\n        //Prepare/init services/factory with deps injected\n        access\n    };\n\n    return Chevron;\n\n}());"]}