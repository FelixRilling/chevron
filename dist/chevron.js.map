{"version":3,"sources":["chevron.js"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"chevron.js","sourcesContent":["var Chevron = (function () {\n'use strict';\n\nconst typeService = function (moduleContent, dependencies) {\n    //Dereference fn to avoid unwanted recursion\n    const serviceFn = moduleContent;\n\n    moduleContent = function () {\n        //Chevron service function wrapper\n        //return function with args injected\n        return serviceFn.apply(null, dependencies.concat(Array.from(arguments)));\n    };\n\n    return moduleContent;\n};\n\nconst typeFactory = function (moduleContent, dependencies) {\n    //dereference array, because we dont wanna mutate the arg\n    const dependenciesArr = Array.from(dependencies);\n    //First value gets ignored by calling 'new' like this, so we need to fill it with something\n    dependenciesArr.unshift(0);\n\n    //Apply into new constructor by binding applying the bind method.\n    //@see: {@link http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible }\n    moduleContent = new (Function.prototype.bind.apply(moduleContent, dependenciesArr))();\n\n    return moduleContent;\n};\n\n/**\n * @private\n * @param {Map} $map Chevron instance map\n * @param {Object} _module module\n * @param {Function} constructorFunction function init the module with\n * @returns {Mixed} constructed module content\n */\n\nconst construct = function ($map, _module, constructorFunction) {\n    const dependencies = [];\n\n    //Collects dependencies\n    _module.deps.forEach(depName => {\n        const dependency = $map.get(depName);\n\n        if (dependency) {\n            dependencies.push(dependency.rdy ? dependency.fn : dependency.init());\n        } else {\n            throw new Error(`Missing '${ depName }'`);\n        }\n    });\n\n    _module.fn = constructorFunction(_module.fn, dependencies);\n    _module.rdy = true;\n\n    return _module.fn;\n};\n\n/**\n * Chevron Constructor\n * @constructor\n * @returns {Object} Chevron instance\n */\nconst ChevronMain = class {\n    constructor() {\n        const _this = this;\n\n        //Instance container\n        _this.$map = new Map();\n\n        //Adds default types\n        _this.extend(\"service\", typeService);\n        _this.extend(\"factory\", typeFactory);\n    }\n    extend(typeName, constructorFunction) {\n        /**\n         * Defines a new module type\n         */\n        const _this = this;\n\n        //stores type with name into instance\n        _this[typeName] = function (id, deps, fn) {\n            _this.provider(id, deps, fn, constructorFunction);\n        };\n\n        return _this;\n    }\n    provider(id, deps, fn, constructorFunction) {\n        /**\n         * Adds a new module to the container\n         */\n        const _this = this;\n        const _module = {\n            deps,\n            fn,\n            rdy: false,\n            init: function () {\n                return construct(_this.$map, _module, constructorFunction);\n            }\n        };\n\n        _this.$map.set(id, _module);\n\n        return _this;\n    }\n    access(id) {\n        /**\n         * Accesses and inits a module\n         */\n        const _module = this.$map.get(id);\n\n        return _module.rdy ? _module.fn : _module.init();\n    }\n};\n\nreturn ChevronMain;\n\n}());\n"]}