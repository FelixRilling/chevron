{"version":3,"sources":["chevron.js"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"chevron.js","sourcesContent":["var Chevron = (function () {\n'use strict';\n\nconst typeService = function (_module, dependencies) {\n    console.log(\"SERVICE\", _module, dependencies);\n\n    //Dereference fn to avoid unwanted recursion\n    const serviceFn = _module.fn;\n\n    _module.fn = function () {\n        //Chevron service function wrapper\n        //return function with args injected\n        return serviceFn.apply(null, dependencies.concat(Array.from(arguments)));\n    };\n\n    return _module;\n};\n\nconst typeFactory = function (_module, dependencies) {\n    console.log(\"FACTORY\", _module, dependencies);\n\n    //First value gets ignored by calling 'new' like this, so we need to fill it with something\n    dependencies.unshift(0);\n\n    //Apply into new constructor by binding applying the bind method.\n    //@see: {@link http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible }\n    _module.fn = new (Function.prototype.bind.apply(_module.fn, dependencies))();\n\n    return _module;\n};\n\nconst construct = function ($map, _module, cf) {\n    const dependencies = [];\n    let constructedModule;\n\n    _module.deps.forEach(depName => {\n        const dependency = $map.get(depName);\n\n        if (dependency) {\n            dependencies.push(dependency.init === true ? dependency.fn : dependency.construct());\n        } else {\n            throw new Error(\"missing \" + depName);\n        }\n    });\n\n    constructedModule = cf(_module, dependencies);\n    _module.init = true;\n\n    return constructedModule.fn;\n};\n\n/**\n * Chevron Constructor\n * @constructor\n * @returns {Object} Chevron instance\n */\nconst Chevron = class {\n    constructor() {\n        const _this = this;\n\n        //Instance container\n        _this.$map = new Map();\n\n        _this.extend(\"service\", typeService);\n        _this.extend(\"factory\", typeFactory);\n    }\n    extend(typeName, cf) {\n        const _this = this;\n\n        _this[typeName] = function (id, deps, fn) {\n            _this.provider(id, deps, fn, cf);\n        };\n    }\n    provider(id, deps, fn, cf) {\n        const _this = this;\n        const entry = {\n            deps,\n            fn,\n            init: false,\n            construct: function () {\n                return construct(_this.$map, entry, cf);\n            }\n        };\n\n        _this.$map.set(id, entry);\n    }\n    access(id) {\n        const _module = this.$map.get(id);\n\n        return _module.init ? _module.fn : _module.construct();\n    }\n};\n\nreturn Chevron;\n\n}());\n"]}